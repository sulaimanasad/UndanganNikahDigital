"use strict";

// Polyfill untuk _typeof
function _typeof(obj) {
  return (_typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol"
    ? function (obj) {
        return typeof obj;
      }
    : function (obj) {
        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype
          ? "symbol"
          : typeof obj;
      })(obj);
}

(function (global) {
  function extend() {
    const target = arguments[0] || {};
    for (let i = 1; i < arguments.length; i++) {
      const source = arguments[i];
      if (source) {
        for (const key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            if (_typeof(source[key]) === "object") {
              target[key] = extend(target[key] || {}, source[key]);
            } else {
              target[key] = source[key];
            }
          }
        }
      }
    }
    return target;
  }

  function createSection(container, options, className) {
    const wrapper = document.createElement("div");
    const amount = document.createElement("span");
    const word = document.createElement("span");
    const section = document.createElement("div");

    section.appendChild(amount);
    section.appendChild(word);
    wrapper.appendChild(section);

    wrapper.classList.add(options.sectionClass, className);
    amount.classList.add(options.amountClass);
    word.classList.add(options.wordClass);

    container.appendChild(wrapper);

    return {
      full: wrapper,
      amount: amount,
      word: word
    };
  }

  global.simplyCountdown = function (element, userOptions) {
    const defaultOptions = {
      year: 2015,
      month: 6,
      day: 28,
      hours: 0,
      minutes: 0,
      seconds: 0,
      words: {
        days: { singular: "day", plural: "days" },
        hours: { singular: "hour", plural: "hours" },
        minutes: { singular: "minute", plural: "minutes" },
        seconds: { singular: "second", plural: "seconds" }
      },
      plural: true,
      inline: false,
      enableUtc: false,
      onEnd: function () {},
      refresh: 1000,
      inlineClass: "simply-countdown-inline",
      sectionClass: "simply-section",
      amountClass: "simply-amount",
      wordClass: "simply-word",
      zeroPad: false,
      countUp: false
    };

    const options = extend({}, defaultOptions, userOptions);
    const elements = typeof element === "string" ? document.querySelectorAll(element) : element;
    const targetDate = new Date(
      options.year,
      options.month - 1,
      options.day,
      options.hours,
      options.minutes,
      options.seconds
    );

    const endDate = options.enableUtc
      ? new Date(
          targetDate.getUTCFullYear(),
          targetDate.getUTCMonth(),
          targetDate.getUTCDate(),
          targetDate.getUTCHours(),
          targetDate.getUTCMinutes(),
          targetDate.getUTCSeconds()
        )
      : targetDate;

    function initCountdown(container) {
      let timer;

      const display = options.inline
        ? (() => {
            const span = document.createElement("span");
            span.classList.add(options.inlineClass);
            container.appendChild(span);
            return span;
          })()
        : {
            days: createSection(container, options, "simply-days-section"),
            hours: createSection(container, options, "simply-hours-section"),
            minutes: createSection(container, options, "simply-minutes-section"),
            seconds: createSection(container, options, "simply-seconds-section")
          };

      function updateCountdown() {
        const now = new Date();
        const currentTime = options.enableUtc
          ? new Date(
              now.getUTCFullYear(),
              now.getUTCMonth(),
              now.getUTCDate(),
              now.getUTCHours(),
              now.getUTCMinutes(),
              now.getUTCSeconds()
            ).getTime()
          : now.getTime();

        let remaining = (endDate.getTime() - currentTime) / 1000;

        let days = 0,
          hours = 0,
          minutes = 0,
          seconds = 0;

        if (remaining > 0) {
          days = Math.floor(remaining / 86400);
          remaining %= 86400;
          hours = Math.floor(remaining / 3600);
          remaining %= 3600;
          minutes = Math.floor(remaining / 60);
          seconds = Math.floor(remaining % 60);
        } else if (options.countUp) {
          remaining = (currentTime - endDate.getTime()) / 1000;
          days = Math.floor(remaining / 86400);
          remaining %= 86400;
          hours = Math.floor(remaining / 3600);
          remaining %= 3600;
          minutes = Math.floor(remaining / 60);
          seconds = Math.floor(remaining % 60);
        } else {
          clearInterval(timer);
          options.onEnd();
        }

        const dayWord = days === 1 ? options.words.days.singular : options.words.days.plural;
        const hourWord = hours === 1 ? options.words.hours.singular : options.words.hours.plural;
        const minuteWord = minutes === 1 ? options.words.minutes.singular : options.words.minutes.plural;
        const secondWord = seconds === 1 ? options.words.seconds.singular : options.words.seconds.plural;

        const zeroPad = (val) => (options.zeroPad && val < 10 ? "0" : "") + val;

        if (options.inline) {
          display.textContent = `${zeroPad(days)} ${dayWord}, ${zeroPad(hours)} ${hourWord}, ${zeroPad(minutes)} ${minuteWord}, ${zeroPad(seconds)} ${secondWord}.`;
        } else {
          display.days.amount.textContent = zeroPad(days);
          display.days.word.textContent = dayWord;

          display.hours.amount.textContent = zeroPad(hours);
          display.hours.word.textContent = hourWord;

          display.minutes.amount.textContent = zeroPad(minutes);
          display.minutes.word.textContent = minuteWord;

          display.seconds.amount.textContent = zeroPad(seconds);
          display.seconds.word.textContent = secondWord;
        }
      }

      updateCountdown();
      timer = setInterval(updateCountdown, options.refresh);
    }

    if (elements && typeof elements[Symbol.iterator] === "function") {
      Array.prototype.forEach.call(elements, (el) => {
        initCountdown(el);
      });
    } else {
      initCountdown(elements);
    }
  };
})(window);

// jQuery plugin support
if (window.jQuery) {
  (function ($, countdown) {
    $.fn.simplyCountdown = function (options) {
      countdown(this.selector, options);
      return this;
    };
  })(jQuery, simplyCountdown);
}
